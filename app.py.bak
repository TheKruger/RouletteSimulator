from flask import Flask, render_template, request
from flask_socketio import SocketIO, emit
import random, time, threading

app = Flask(__name__)
app.config["SECRET_KEY"] = "secret"
socketio = SocketIO(app, cors_allowed_origins="*", async_mode="threading")

players = {}
bets = {}
round_active = False

def game_loop():
    global round_active, bets
    while True:
        # Kör kezdete
        round_active = True
        socketio.emit("round_status", {"status": "open"})
        print("[INFO] Betting opened")
        time.sleep(10)  # 10 másodperc tétleadásra

        # Kör vége
        round_active = False
        print("[INFO] Betting closed")
        winning_number = random.randint(0, 36)
        winning_color = "red" if winning_number % 2 == 0 else "black"

        print(f"[INFO] Winning number: {winning_number} ({winning_color})")
        socketio.emit("result", {"number": winning_number, "color": winning_color})

        # Eredmények feldolgozása
        for sid, bet in bets.items():
            payout = 0
            amount = bet["amount"]
            choice = bet["choice"]
            btype = bet["type"]

            if btype == "color" and choice == winning_color:
                payout = amount * 2
            elif btype == "parity" and ((winning_number % 2 == 0) == (choice == "even")):
                payout = amount * 2
            elif btype == "range" and ((1 <= winning_number <= 18) == (choice == "low")):
                payout = amount * 2
            elif btype == "number" and choice == winning_number:
                payout = amount * 35

            players[sid]["balance"] += payout - amount
            if players[sid]["balance"] <= 0:
                players[sid]["balance"] = 1000

        bets.clear()
        socketio.emit("update_players", players)
        time.sleep(5)  # kis szünet, majd új kör

@app.route("/")
def index():
    return render_template("index.html")

@socketio.on("connect")
def connect():
    sid = request.sid
    players[sid] = {"name": f"Player-{sid[:4]}", "balance": 1000}
    print(f"[INFO] {players[sid]['name']} connected")
    emit("update_players", players, broadcast=True)

@socketio.on("place_bet")
def place_bet(data):
    sid = request.sid
    global round_active

    if not round_active:
        emit("error", {"message": "Betting closed"})
        return

    amount = int(data["amount"])
    btype = data["type"]
    choice = data["choice"]

    if players[sid]["balance"] >= amount:
        bets[sid] = {"type": btype, "choice": choice, "amount": amount}
        print(f"[BET] {players[sid]['name']} bet {amount} on {btype}={choice}")
        emit("bet_placed", {"player": players[sid]["name"], **data}, broadcast=True)
    else:
        emit("error", {"message": "Not enough balance"})

@socketio.on("disconnect")
def disconnect():
    sid = request.sid
    if sid in players:
        print(f"[INFO] {players[sid]['name']} disconnected")
        players.pop(sid)
    if sid in bets:
        bets.pop(sid)
    emit("update_players", players, broadcast=True)

if __name__ == "__main__":
    threading.Thread(target=game_loop, daemon=True).start()
    socketio.run(app, host="0.0.0.0", port=5000, debug=True)
